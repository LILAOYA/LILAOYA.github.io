[{"id":"fa9bcae6ffd4e6d8723c276168217c7b","title":"本地项目部署到gitee以及仓库分支","content":"一、如何将本地项目上传到码云\n使用git bash，进入项目文件的根目录下\n使用git init命令 （初始化一个git 本地仓库，此时会在本地项目文件创建一个 .git 的文件夹）\n使用git remote add origin https://gitee.com/XXXX （添加项目远程仓库）\n使用git add .    （将文件保存到缓存区）\n（. 表示项目下所有的文件）或者可以 git add + 文件名\n\n\n使用git commit -m ‘新添加的文件内容描述’ （添加描述）\n使用git push origin master （将本地仓库推送到远程仓库的master分支，也就是默认的主分支）\n\n二、在gitee码云上用 git 新建分支\n\n\n\n\n\n\n\n\n需求： 开发中遇到优化请求，但是尚未测试通过，不能直接并入主版本。\n此时考虑新建git分支。以gitee为例：\n\n在gitee项目中新建一个远程分支，我取名dev\n\n\n打开本地项目git命令终端，新建dev分支\ngit checkout -b dev（分支名）\n此时，可以用git branch -a 查看项目的分支情况\n\n拉取远程分支\ngit pull origin dev\n建立本地分支与远程分支的连接\ngit branch --set-upstream-to=origin/dev  （分支名）\n提交\ngit add .\ngit commit -m \"xxx\"\ngit push origin dev(分支名)\n\n","slug":"本地项目部署到gitee以及仓库分支","date":"2022-02-22T08:13:10.000Z","categories_index":"网站建设","tags_index":"随笔","author_index":"LIYA的极光"},{"id":"f0537590fd58ea3759acae4e95b00914","title":"使用hexo框架创建blog","content":"1.安装必要的环境\n先下载node.js用cmd输入node -v和npm -v来查看安装的版本，确定安装成功。\n安装淘宝的cnpm 管理器npm install -g cnpm –registry&#x3D;http://registry.npm.taobao.org cnpm 是什么？ npm的中国版镜像，由于npmjs.org的服务器在国外（即在“墙”外），国（墙）内开发者做项目的时候，很多“包”的下载速度极慢，在这种环境下阿里巴巴为了众多开发者的便捷便挺身而出推出了淘宝镜像（即cnpm），它把npm官方的“包”全部搬到国内，供广大开发者使用。\ncnpm -v &#x2F;&#x2F;查看cnpm版本，确定安装成功。\ncnpm install -g hexo-cli  &#x2F;&#x2F;安装hexo框架\nhexo -v &#x2F;&#x2F;查看hexo版本\nmkdir 目录名 &#x2F;&#x2F;创建blog项目目录\ncd 目录名 &#x2F;&#x2F;进入blog目录\nhexo init &#x2F;&#x2F;生成博客项目 初始化博客\nhexo s &#x2F;&#x2F;启动本地博客服务\n\n2.用hexo命令生成文章文件hexo n 文章名 &#x2F;&#x2F;创建新的文章&#x2F;&#x2F;进入到文章所在目录进行编辑\n3.修改博客主题点击这里发现更多主题\n\n用命令行进入博客项目所在的文件夹,git clone 主题所在的github地址 示例代码：\n git clone https:&#x2F;&#x2F;github.com&#x2F;miccall&#x2F;hexo-theme-Mic_Theme\n\n克隆完毕后，把克隆下来的主题文件夹放到themes文件夹里。\n\n在项目的根目录，修改 _config.yml 内的 theme 值为你克隆到本地主题文件夹的名字。\n\nhexo c &#x2F;&#x2F;清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\nhexo g &#x2F;&#x2F;生成静态文件。\n\nhexo s &#x2F;&#x2F;启动服务，查看效果\n4.部署到github或gitee\n\n修改 _config.yml（是部署到仓库的关键） \ndeploy:\n  type: git\n  repository: https:&#x2F;&#x2F;github.com&#x2F;LILAOYA&#x2F;LILAOYA.github.io.git\n  (仓库地址:可以是github也可以是gitee)\n  branch: master\n安装hexo-deployer-git插件，在站点目录下输入下面的插件安装就好了：npm install hexo-deployer-git –savehexo d &#x2F;&#x2F;部署到远程Github&#x2F;gitee仓库Hexo 部署到 Gitee\n5.hexo发生error：spawn failed错误的解决方法问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。解决办法：\n\n删除.deploy_git文件夹;rm -rf .deploy_git&#x2F;\n输入git config –global core.autocrlf false然后，依次执行：hexo chexo ghexo d\n\n","slug":"使用hexo框架创建博客","date":"2022-02-22T08:13:10.000Z","categories_index":"网站建设","tags_index":"随笔","author_index":"LIYA的极光"},{"id":"8eec314ae055e7cdaccd8bbfdd5ebd88","title":"hexo博客图片显示异常的问题","content":"case1：本地预览图片失败第一步1.找到Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true。2.在Hexo目录下打开Git Brsh或cmd，执行一个下载上传图片插件的命令npm install hexo-asset-image –save3..继续在Git Brsh或cmd下利用hexo n ’文章名’生成一个文章(.md)，这时就会在同级的目录下生成一个和文章同名的文件夹。\n第二步1.在.md的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。2.利用markdown的语法将文件引入文章中。例如：\n![这是图片](&lt;span&gt; 和文章同名的文件夹&#x2F;图片.jpg &quot;图片描述&quot; )\n3.最后再启动一下\n注意1.下载插件是关键2.下载插件后，新生成的文章的同名文件夹放图片，在文章里用![这是图片]( 和文章同名的文件夹&#x2F;图片.jpg “图片描述”)即可引入图片3.下载插件后，在下载插件之前生成的文章，你需要手动在同级目录下创建一个同名文件夹，其他步骤同上。4.如果新创建了一个博客，还需要装插件。5.这个方式在本地编辑时有效，启动服务后无效。\ncase2：部署到服务器后图片加载失败插入图片时用这种方式：\n&#123;% asset_img test.jpg  This is an test image %&#125;\n其中test.jpg就是你要引用的图片，我这里就是test.jpg，后面的This is an test image是图片描述，可以自己修改。\n注意：1.下载插件是大前提2.在本地编辑文档时这个命令无效，启动服务后有效\n","slug":"hexo博客图片显示异常的问题","date":"2021-08-03T10:19:33.000Z","categories_index":"网站建设","tags_index":"随笔","author_index":"LIYA的极光"},{"id":"dad0a65e340d9a1a17eb79c659785ca0","title":"Mybatis通过注解批量插入/删除","content":"一、概述我们在写Mapper的时候，经常会通过注解的方式来写SQL语句，像下面这样。这要求我们传递的参数为一个具体的对象。\n@Insert(\"INSERT INTO student (name, sex, addr) VALUES (#&#123;name&#125;, #&#123;sex&#125;, #&#123;addr&#125;)\")\nint insert(Student stu);\n但是，如果需要批量插入List&lt; Student &gt; studentList；不可能遍历studentList并依次执行插入语句，这样效率太差。还有一种是配置Mybatis的xml文件，反正题主觉得那个配置好复杂。有没有还是通过注解的方式，执行批量操作呢？\n二、批量执行我们回想下SQL语句，插入一条记录：\nINSERT INTO student (name, sex, addr) VALUES (\"LiMing\", 0, \"Beijing\");\n批量插入：\nINSERT INTO student (name, sex, addr) VALUES (\"LiMing\", 0, \"Beijing\"), (\"LiNing\", 0, \"Shanghai\");\n\n根据 id 删除一条记录：\nDELETE FROM student WHERE id = 1;\n根据ids批量删除：\nDELETE FROM student WHERE id IN (1, 2, 3);\n三、方法既然可以通过SQL语句批量执行，那我们可以修改注解。这里需要通过自定义Provider来实现。\n@Component\n@Mapper\npublic interface StudentMapper &#123;\n    @Insert(\"INSERT INTO student (name, sex, addr) VALUES (#&#123;name&#125;, #&#123;sex&#125;, #&#123;addr&#125;)\")\n    int insert(Student stu);\n\n    @Select(\"SELECT * FROM student\")\n    List&lt;Student> selectAll();\n\n    @Select(\"SELECT * FROM student WHERE id = #&#123;id&#125;\")\n    Student selectById(@Param(\"id\") int id);\n\n    @InsertProvider(type = Provider.class, method = \"batchInsert\")\n    int batchInsert(List&lt;Student> students);\n\n    @DeleteProvider(type = Provider.class, method = \"batchDelete\")\n    int batchDelete(List&lt;Student> students);\n\n    \n\n\n    class Provider &#123;\n        /* 批量插入 */\n        public String batchInsert(Map map) &#123;\n            List&lt;Student> students = (List&lt;Student>) map.get(\"list\");\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"INSERT INTO student (name,sex,addr) VALUES \");\n            MessageFormat mf = new MessageFormat(\n                    \"(#'&#123;'list[&#123;0&#125;].name&#125;, #'&#123;'list[&#123;0&#125;].sex&#125;, #'&#123;'list[&#123;0&#125;].addr&#125;)\"\n            );\n\n            for (int i = 0; i &lt; students.size(); i++) &#123;\n                sb.append(mf.format(new Object[] &#123;i&#125;));\n                if (i &lt; students.size() - 1)\n                    sb.append(\",\");\n            &#125;\n            return sb.toString();\n        &#125;\n\n        /* 批量删除 */\n        public String batchDelete(Map map) &#123;\n            List&lt;Student> students = (List&lt;Student>) map.get(\"list\");\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"DELETE FROM student WHERE id IN (\");\n            for (int i = 0; i &lt; students.size(); i++) &#123;\n                sb.append(\"'\").append(students.get(i).getId()).append(\"'\");\n                if (i &lt; students.size() - 1)\n                    sb.append(\",\");\n            &#125;\n            sb.append(\")\");\n            return sb.toString();\n        &#125;\n    &#125;\n&#125;","slug":"Mybatis通过注解批量插入删除","date":"2022-03-18T04:00:15.000Z","categories_index":"mybatis","tags_index":"转载","author_index":"LIYA的极光"},{"id":"ab49bc5bb50743ab3f03186f41f79e32","title":"spring.05.AOP面向切面编程","content":"一、AOP简介Aop（aspect orient programming） ，面向切面编程。面向切面编程是从动态角度考虑程序运行过程。\nAOP底层，就是采用动态代理模式实现的，采用了两种代理：JDK的动态代理，CGLIB的动态代理。\n代理实现程序功能的统一维护的一种技术。\nAOP 是 Spring 框架中的一个重要内容 。利用 AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程\n序的可重用性，同时提高了开发的效率。\n\n1.理解AOP1)要理解切面编程，就需要先理解什么是切面。用刀把一个西瓜分成两瓣，切开的切口就是切面；炒菜，锅与炉子共同来完成炒菜，锅与炉子就是切面。web层级设计中，web层-&gt;网关层-&gt;服务层-&gt;数据层，每一层之间也是一个切面。编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。2)面向切面编程，就是将交叉业务逻辑封装成切面，利用AOP 容器的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志 、缓存等。若不使用AOP ，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样会使主业务逻辑变的混杂不清。\n例如，转账，在真正转账业务逻辑前后，需要权限控制、日志记录、加载事务、结束事务等交叉业务逻辑，\n而这些 业务逻辑与主业务逻辑间并无直接关系。但，它们的代码量所占比重能达到总代码量的一半甚至还多。\n它们的存在，不仅产生了大量的“冗余”代码，还大大干扰了主业务逻辑 转账。\n\n2.AOP有什么好处？1.减少重复；2.专注业务；注意：面向切面编程只是面向对象编程的一种补充。\n我们一般做活动的时候，一般对每一个接口都会做活动的有效性校验（是否开始、是否结束等等）、以及这个接口是不是需要用户登录。\n\n按普通人的逻辑\n\n但是这样的话，很多接口就会产生大量重复的代码，而且耦合度太高，牵一发而动全身。\n大神的逻辑\n 于是就有了切面的概念，我将方法注入到接口调用的某个地方（切点）。这样接口只需要关心具体的业务，而不需要关注其他非该接口关注的逻辑或处理。 红框处，就是面向切面编程。\n\n3.AOP中的重要概念\nAspect（切面）：  切面泛指交叉业务逻辑。一个项目中的琐碎事务处理、日志处理就可以理解为切面。常用的切面是通知（Advice）。实际就是对主业务逻辑的一种增强。在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。\nJointpoint（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。\nPointcut（切入点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。\nAdvice（叫通知也叫增强）：Advice表示切面的执行时间。它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。\nTarget（目标对象）：织入Advice 的目标对象。\nWeaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程\n\n最后是一个描述这些概念之间关系的图：\n\n4.面向切面编程简单总结1）需要在分析项目功能时，找出切面。2）合理安排切面的执行时间，target之前还是之后还是代替执行的代码。3）合理安排切面的执行位置，在哪个类、哪个方法增加增强功能。\n","slug":"spring.05.AOP面向切面编程","date":"2022-03-11T14:26:19.000Z","categories_index":"spring","tags_index":"编程备忘录","author_index":"LIYA的极光"},{"id":"6c65710579b101172a7def9fe9f8af7c","title":"spring.04.基于注解的DI","content":"基于注解的DI：通过注解完成Java对象的创建，属性赋值。\n1.使用注解的步骤：\n加入maven的依赖spring-context，在你加入spring-context的同时，间接加入spring-aop的依赖。使用注解必须使用spring-aop依赖\n在类中加入spring的注解（多个不同功能的注解）\n在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置\n\n常用注解：\n1）@Component\n2) @Repository\n3) @Service\n4) @Controller\n5) @Value\n6) @Autowired\n7) @Resource\n\n2.实现步骤\n加入依赖\n创建类，在类中加入注释\n创建spring的配置文件，声明组件扫描器的标签，指名注解在你的项目中的位置。\n使用注解创建对象，创建容器ApplicationContext3.要学习的注解：1）@Component@Component: 创建对象的， 等同于&lt;bean>的功能\n    属性：value 就是对象的名称，也就是bean的id值，\n          value的值是唯一的，创建的对象在整个spring容器中就一个\n     位置：在类的上面\n\n  @Component(value = \"myStudent\")等同于\n   &lt;bean id=\"myStudent\" class=\"com.bjpowernode.ba01.Student\" />\n\n  spring中和@Component功能一致，创建对象的注解还有：\n  1.@Repository（用在持久层类的上面） : 放在dao的实现类上面，\n               表示创建dao对象，dao对象是能访问数据库的。\n  2.@Service(用在业务层类的上面)：放在service的实现类上面，\n              创建service对象，service对象是做业务处理，可以有事务等功能的。\n  3.@Controller(用在控制器的上面)：放在控制器（处理器）类的上面，创建控制器对象的，\n              控制器对象，能够接受用户提交的参数，显示请求的处理结果。\n  以上三个注解的使用语法和@Component一样的。 都能创建对象，但是这三个注解还有额外的功能。\n  @Repository，@Service，@Controller是给项目的对象分层的。\n代码p1：Student.javapackage com.bjpowernode.ba01;\nimport org.springframework.stereotype.Component;\n//使用value属性，指定对象名称\n//@Component(value = \"myStudent\")\n\n//可以这么用，省略value\n@Component(\"myStudent\")\n\n//不指定对象名称，由spring提供默认名称: 类名的首字母小写\n//@Component\npublic class Student &#123;\n\n    private String name;\n    private Integer age;\n\n    public Student() &#123;\n        System.out.println(\"==student无参数构造方法===\");\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void setAge(Integer age) &#123;\n        this.age = age;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n代码p2：applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    &lt;!--声明组件扫描器(component-scan),组件就是java对象\n        base-package：指定注解在你的项目中的包名。\n        component-scan工作方式： spring会扫描遍历base-package指定的包，\n           把包中和子包中的所有类，找到类中的注解，按照注解的功能创建对象，或给属性赋值。\n\n       加入了component-scan标签，配置文件的变化：\n        1.加入一个新的约束文件spring-context.xsd\n        2.给这个新的约束文件起个命名空间的名称\n    -->\n    &lt;context:component-scan base-package=\"com.bjpowernode.ba01\" />\n&lt;!--指定多个包的三种方式：-->\n     &lt;!--第一种：使用多次组件扫描器-->\n     &lt;context:component-scan base-package=\"com.bjpowernode.ba01\" />\n     &lt;context:component-scan base-package=\"com.bjpowernode.ba02\" />\n     &lt;context:component-scan base-package=\"com.bjpowernode.ba03\" />\n     ....\n     &lt;!--第二种：使用分隔符;或,分隔多个包名-->\n     &lt;context:component-scan base-package=\"com.bjpowernode.ba01;com.bjpowernode.ba02;com.bjpowernode.ba03\" />\n     &lt;!--第三种：指定父包-->\n     &lt;context:component-scan base-package=\"com.bjpowernode\" />\n\n&lt;/beans>\n2）@Value@Value：简单类型的属性赋值属性：value是String类型的，表示简单类型的属性值位置：1.写在属性定义的上面，无需set方法 2.写在set方法的上面，不如第一种方便\n\n代码p1：Student.javapackage com.bjpowernode.ba01;\nimport org.springframework.stereotype.Component;\n//使用value属性，指定对象名称\n//@Component(value = \"myStudent\")\n\n//可以这么用，省略value\n@Component(\"myStudent\")\n\n//不指定对象名称，由spring提供默认名称: 类名的首字母小写\n//@Component\npublic class Student &#123;\n    @Value(\"利亚\")\n    private String name;\n    @Value(\"18\")\n    private Integer age;\n/*\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void setAge(Integer age) &#123;\n        this.age = age;\n    &#125;\n*/\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n3）@Autowired@Autowired：spring框架提供的注解，实现引用类型的赋值（默认byType）。spring中通过注解给引用类型赋值，使用的是自动注入原理，支持byName，byType。位置：1）在属性定义的上面，无需set方法      2）在set方法的上面\n代码p1：引用类型的赋值，默认使用byType@Component(\"myStudent\")\npublic class Student &#123;\n     @Value(\"利亚\")\n    private String name;\n     @Value(\"18\")\n    private Integer age;\n    //对引用的类型的赋值\n    @Autowired\n    private School school;\n/*\n    public Student() &#123;\n        System.out.println(\"==student无参数构造方法===\");\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void setAge(Integer age) &#123;\n        this.age = age;\n    &#125;\n    */\n\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n\n@Component(\"mySchool\")\nclass School\n &#123;\n    @Value(\"北大\")\n    private String name;\n    @Value(\"北京的海淀区\") \n    private String address;\n\n    其他部分省略。。\n &#125;\n代码p2：引用类型的赋值，使用byName@Autowired@Qualifier(value&#x3D;”XXX”)\n@Component(\"mySchool\")\nclass School\n &#123;\n    @Value(\"北大\")\n    private String name;\n    @Value(\"北京的海淀区\") \n    private String address;\n\n    其他部分省略。。\n &#125;\n\n@Component(\"myStudent\")\npublic class Student &#123;\n     @Value(\"利亚\")\n    private String name;\n     @Value(\"18\")\n    private Integer age;\n    //对引用的类型的赋值\n    @Autowired\n    @Qualifier(value=\"mySchool\")\n    private School school;\n\n\n    @Override\n    public String toString() &#123;\n        return \"Student&#123;\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n&#125;\n4）@Resource@Resource：来自jdk的注解，spring的框架提供了对这个注解的功能支持，可以使用它给引用类型赋值，使用的也是自动注入原理，支持byName（默认）、byType。@Resource（name&#x3D;””）：默认是byName，先使用byName自动注入，如果name未找到就使用byType位置：\n\n写在属性定义的上面，无需set方法\n写在set方法的上面\n\n5）@Repository创建dao对象，用来访问数据库\n6）@Service创建Service对象，处理业务逻辑，可以有事务功能\n7）@Controller创建控制器对象，接收请求、显示处理结果\n","slug":"spring.04.基于注解的DI","date":"2022-03-11T14:26:16.000Z","categories_index":"spring","tags_index":"编程备忘录","author_index":"LIYA的极光"},{"id":"dbac222cea299f8d84b40392321badcf","title":"spring.03.spring的自动注入","content":"spring引用类型的自动注入引用类型的自动注入： spring框架根据某些规则可以给引用类型赋值。不用手动给引用类型赋值了。使用的规则常用的是byName, byType。\n1.byName(按名称注入) ：java类中引用类型的属性名和spring容器中（配置文件）&lt;bean>的id名称一样，\n且数据类型是一致的，这样的容器中的bean，spring能够赋值给引用类型。\n 语法：\n    &lt;bean id=\"xx\" class=\"yyy\" autowire=\"byName\">\n            简单类型属性赋值\n    &lt;/bean>\n实例： Student.java\nclass Student\n&#123;\n   private String name; \n   private int age;\n\n   private School school;//School对象的id要和student的引用类型属性名一致\n\n   其他部分省略。。\n&#125; &lt;!--byName-->\n    &lt;bean id=\"myStudent\" class=\"com.bjpowernode.ba04.Student\"  autowire=\"byName\">&lt;!--加上autowire=\"byName\"-->\n        &lt;property name=\"name\" value=\"李四\" />\n        &lt;property name=\"age\" value=\"26\" />\n        &lt;!--引用类型-->\n        &lt;!--这句就用不着了&lt;property name=\"school\" ref=\"mySchool\" />-->\n    &lt;/bean>\n\n    &lt;!--声明School对象-->\n    &lt;bean id=\"school\" class=\"com.bjpowernode.ba04.School\">\n        &lt;property name=\"name\" value=\"清华大学\"/>\n        &lt;property name=\"address\" value=\"北京的海淀区\" />\n    &lt;/bean>\n\n    结果成功执行。。。\n2.byType(按类型注入) ：java类中引用类型的数据类型和spring容器中（配置文件）&lt;bean>的class属性是同源关系的，这样的bean能够赋值给引用类型.\n同源就是一类的意思：\n          case1：java类中引用类型的数据类型和bean的class的值是一样的。\n          case2：java类中引用类型的数据类型和bean的class的值父子类关系的。\n          case3：java类中引用类型的数据类型和bean的class的值接口和实现类关系的\n         语法：\n         &lt;bean id=\"xx\" class=\"yyy\" autowire=\"byType\">\n            简单类型属性赋值\n         &lt;/bean>\ncase1： Student.java\nclass Student\n&#123;\n   private String name; \n   private int age;\n\n   private School school;//引用类型名要和bean的Class名相同\n\n   其他部分省略。。\n&#125;\n&lt;!--byType-->\n   &lt;bean id=\"myStudent\" class=\"com.bjpowernode.ba05.Student\"  autowire=\"byType\">\n       &lt;property name=\"name\" value=\"张飒\" />\n       &lt;property name=\"age\" value=\"26\" />\n       &lt;!--引用类型-->\n       &lt;!--&lt;property name=\"school\" ref=\"mySchool\" />-->\n   &lt;/bean>\n\n   &lt;!--声明School对象-->\n   &lt;bean id=\"mySchool\" class=\"com.bjpowernode.ba05.School\">&lt;!--bean的类名为School-->\n       &lt;property name=\"name\" value=\"人民大学\"/>\n       &lt;property name=\"address\" value=\"北京的海淀区\" />\n   &lt;/bean>\n\n    结果成功执行。。。\ncase2：\nStudent.java\n class Student\n &#123;\n    private String name; \n    private int age;\n\n    private School school=new PrimarySchool();//引用类型的对象是其子类\n\n    其他部分省略。。\n &#125;\n School.java\n class School\n &#123;\n    private String name; \n    private String address;\n\n    其他部分省略。。\n &#125;\n PrimarySchool.java\n class PrimarySchool extends School&#123;\n\n &#125;\n &lt;!--声明School的子类-->\n  &lt;bean id=\"primarySchool\" class=\"com.bjpowernode.ba05.PrimarySchool\">\n      &lt;property name=\"name\" value=\"北京小学\" />\n      &lt;property name=\"address\" value=\"北京的大兴区\" />\n  &lt;/bean>\n  结果同理\n case3略\n","slug":"spring.03.spring的自动注入","date":"2022-03-11T14:26:15.000Z","categories_index":"spring","tags_index":"编程备忘录","author_index":"LIYA的极光"},{"id":"fa52b34bae7d4c54b1124245f3ed007f","title":"spring.02.spring基于xml的DI","content":"spring基于xml的DI di（依赖注入）:给属性赋值 bean实例在调用无参构造器创建对象后，要对bean对象的属性进行初始化。初始化是容器自动完成的，称为注入。注入：就是赋值的意思 根据注入方式的不同，常用的有两类：set注入、构造注入。\n1. set注入（设值注入） ：spring调用类的set方法， 你可以在set方法中完成属性赋值 1）简单类型的set注入 示例如下：\n &lt;bean id=\"xx\" class=\"yyy\">\n    &lt;property name=\"属性名字\" value=\"此属性的值\"/>\n        一个property只能给一个属性赋值\n    &lt;property....>\n&lt;/bean>\n2）引用类型的set注入：spring调用类的set方法\n&lt;bean id=\"xxx\" class=\"yyy\">\n    &lt;property name=\"属性名称\" ref=\"bean的id(对象的名称)\" />\n&lt;/bean>\n2.构造注入：spring调用类有参数构造方法，在创建对象的同时，在构造方法中给属性赋值。 构造注入使用 &lt;constructor-arg&gt; 标签\n&lt;constructor-arg&gt; 标签：一个&lt;constructor-arg&gt;表示构造方法一个参数。\n &lt;constructor-arg&gt; 标签属性：\n name:表示构造方法的形参名\nindex:表示构造方法的参数的位置，参数从左往右位置是 0 ， 1 ，2的顺序\nvalue：构造方法的形参类型是简单类型的，使用value\n ref：构造方法的形参类型是引用类型的，使用ref\n\n示例如下：\n\n &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n&lt;!--使用name属性实现构造注入-->\n    &lt;bean id=\"myStudent\" class=\"com.bjpowernode.ba03.Student\" >\n        &lt;constructor-arg name=\"myage\" value=\"20\" />\n        &lt;constructor-arg name=\"mySchool\" ref=\"myXueXiao\" />\n        &lt;constructor-arg name=\"myname\" value=\"周良\"/>\n    &lt;/bean>\n\n    &lt;!--使用index属性-->\n    &lt;bean id=\"myStudent2\" class=\"com.bjpowernode.ba03.Student\">\n        &lt;constructor-arg index=\"1\" value=\"22\" />\n        &lt;constructor-arg index=\"0\" value=\"李四\" />\n        &lt;constructor-arg index=\"2\" ref=\"myXueXiao\" />\n    &lt;/bean>\n\n    &lt;!--省略index-->\n    &lt;bean id=\"myStudent3\" class=\"com.bjpowernode.ba03.Student\">\n        &lt;constructor-arg  value=\"张强强\" />\n        &lt;constructor-arg  value=\"22\" />\n        &lt;constructor-arg  ref=\"myXueXiao\" />\n    &lt;/bean>\n    &lt;!--声明School对象-->\n    &lt;bean id=\"myXueXiao\" class=\"com.bjpowernode.ba03.School\">\n        &lt;property name=\"name\" value=\"清华大学\"/>\n        &lt;property name=\"address\" value=\"北京的海淀区\" />\n    &lt;/bean>\n\n    &lt;!--创建File,使用构造注入-->\n    &lt;bean id=\"myfile\" class=\"java.io.File\">\n        &lt;constructor-arg name=\"parent\" value=\"D:\\course\\JavaProjects\\spring-course\\ch01-hello-spring\" />\n        &lt;constructor-arg name=\"child\" value=\"readme.txt\" />\n    &lt;/bean>\n\n&lt;/beans>\n","slug":"spring.02.spring基于xml的DI","date":"2022-03-11T14:16:15.000Z","categories_index":"spring","tags_index":"编程备忘录","author_index":"LIYA的极光"},{"id":"b153846ea7b11a1e236e2e9eb42afa6c","title":"spring.01.初步了解spring以及IOC","content":"1.spring简述Spring是一个轻量级的开源框架，是为解决企业级应用开发的复杂性而创建的，通过核心的Bean factory实现了底层的类的实例化和生命周期的管理。   Spring的最根本使命是：简化java开发。\n\n优点\n\nSpring是一个开源免费的框架 \nSpring是一个轻量级，非侵入式的\n控制反转（ IoC）  , 面向切面 （Aop）\n\nSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n\n组成\n\n\nSpring是一个三层架构，也为J2EE应用程序开发提供集成的框架；      1）Web层：Spring MVC；      2）业务层 ：Spring的IoC；      3）持久层 ：Spring的JDBC、ORM、等持久层框架；  Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .  \n  组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：\n   核心容器：  核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\n**Spring 上下文：**\nSpring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\n\n**Spring AOP：**\n通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。\n\n**Spring DAO：**\nJDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\n\n**Spring ORM：**\nSpring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\n\n**Spring Web 模块：**\nWeb 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\n\n**Spring MVC 框架：**\nMVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n\n2.spring扩展  Spring Boot与Spring Cloud  Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务;\n\nSpring Cloud是基于Spring Boot实现的；\n\nSpring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架；\n\nSpring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。\n\nSpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot。\n3.IOC理论\n\n控制反转（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫依赖查找（Dependency Lookup）。\n\n起源早在2004年，Martin Fowler就提出了“哪些方面的控制被反转了？”这个问题。他总结出是依赖对象的获得被反转了，因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。\n\n技术描述Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式地用 new 创建 B 的对象。\n\n\n采用依赖注入技术之后，A 的代码只需要定义一个 private 的B对象，不需要直接 new 来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。\n\n实现方法实现控制反转主要有两种方式：依赖注入和依赖查找。两者的区别在于，前者是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中，而后者是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制。\n\n依赖注入依赖注入有如下实现方式：\n\n基于接口。实现特定接口以供外部容器注入所依赖类型的对象。基于 set 方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。\n基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。\n基于注解。基于Java的注解功能，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。\n\n依赖查找依赖查找更加主动，在需要的时候通过调用框架提供的方法来获取对象，获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态\n总结：控制：创建对象、对象的属性赋值、对象之间的关系管理。反转：把原来开发人员创建、管理对象的权限转移给代码之外的容器去实现，由容器代替开发人员去创建对象、对象的属性赋值、对象之间的关系管理。容器：是一个服务器软件，一个框架（spring）。\n 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 ! \n 明白IOC的思想，是理解Spring的核心技巧。\n4.IOC的技术实现DI（dependency injection）是ioc的技术实现依赖注入，只需要在程序中提供要使用的对象名称就可以，至于对象如何在容器中被创建、赋值、查找..都由容器内部实现。spring是使用了di实现了ioc的功能，spring底层创建对象，使用的是反射机制点击观看-&gt;使用spring容器创建对象教程\n","slug":"spring.01.初步了解spring以及IOC","date":"2022-03-11T14:00:15.000Z","categories_index":"spring","tags_index":"编程备忘录","author_index":"LIYA的极光"},{"id":"3c722e589e421720b87a9e591e2b274d","title":"TS型网页视频下载方法","content":"\n\n\n\n\n\n\n\n\n有些网页上的视频是分成多个ts片段的，无法被chrome的各种嗅探器插件捕获，但通过F12开发工具监测网络（Network）文件可以发现（如题图）。\n\n\n\n\n在过滤器中输入m3u8，可以发现一个独立的m3u8文件，这个文件就是记录了所有ts文件片段的一个播放列表。如果没有发现独立的m3u8文件，有可能每一个ts文件的地址中也是含有这个m3u8文件的名称的。把这个m3u8文件的完整地址截取出来。\n\n假设地址为——https://xxxyyy.net/zzz/3e49b3a020e.m3u8\n\n使用ffmpeg（FFmpeg）下载合并输出为一个视频文件——下载ffmpeg、配置好环境变量，接着打开cmd输入下面命令：ffmpeg -i https://xxxyyy.net/zzz/3e49b3a020e.m3u8 -c copy output.mp4\n\n\n注意事项：默认视频存放位置在cmd所在的目录下\n","slug":"TS型网页视频下载方法","date":"2022-03-01T11:26:15.000Z","categories_index":"白嫖小技巧","tags_index":"随笔","author_index":"LIYA的极光"},{"id":"e6658fae850fcd323fa96fcb491a2293","title":"图片测试01","content":"图片\n\n\n","slug":"图片测试01","date":"2021-08-03T09:37:43.000Z","categories_index":"网站测试","tags_index":"测试","author_index":"LIYA的极光"},{"id":"8198d2d0b08b0fb5149d70b4952b4a83","title":"带图片的博客","content":"湖泊\n第二\n\n\n","slug":"带图片的博客","date":"2021-08-03T08:13:10.000Z","categories_index":"网站测试","tags_index":"测试","author_index":"LIYA的极光"},{"id":"288249abbe844be907042b49afdc1c01","title":"正气歌","content":"南宋 文天祥\n余囚北庭，坐一土室。室广八尺，深可四寻。单扉低小，白间短窄，污下而幽暗。\n当此夏日，诸气萃然：雨潦四集，浮动床几，时则为水气；\n涂泥半朝，蒸沤历澜，时则为土气；乍晴暴热，风道四塞，时则为日气；\n檐阴薪爨，助长炎虐，时则为火气；仓腐寄顿，陈陈逼人，时则为米气；\n骈肩杂遝，腥臊汗垢，时则为人气；或圊溷、或毁尸、或腐鼠，恶气杂出，时则为秽气。\n叠是数气，当之者鲜不为厉。而予以孱弱，俯仰其间，於兹二年矣，幸而无恙，是殆有养致然尔。然亦安知所养何哉？\n孟子曰：「吾善养吾浩然之气。」彼气有七，吾气有一，以一敌七，吾何患焉！况浩然者，乃天地之正气也，作正气歌一首。\n天地有正气，杂然赋流形。下则为河岳，上则为日星。於人曰浩然，沛乎塞苍冥。\n皇路当清夷，含和吐明庭。时穷节乃见，一一垂丹青。在齐太史简，在晋董狐笔。\n在秦张良椎，在汉苏武节。为严将军头，为嵇侍中血。为张睢阳齿，为颜常山舌。\n或为辽东帽，清操厉冰雪。或为出师表，鬼神泣壮烈。或为渡江楫，慷慨吞胡羯。\n或为击贼笏，逆竖头破裂。是气所磅礴，凛烈万古存。当其贯日月，生死安足论。\n地维赖以立，天柱赖以尊。三纲实系命，道义为之根。嗟予遘阳九，隶也实不力。\n楚囚缨其冠，传车送穷北。鼎镬甘如饴，求之不可得。阴房阗鬼火，春院闭天黑。\n牛骥同一皂，鸡栖凤凰食。一朝蒙雾露，分作沟中瘠。如此再寒暑，百疠自辟易。\n哀哉沮洳场，为我安乐国。岂有他缪巧，阴阳不能贼。顾此耿耿存，仰视浮云白。\n悠悠我心悲，苍天曷有极。哲人日已远，典刑在夙昔。风檐展书读，古道照颜色。\n","slug":"正气歌","date":"2021-07-27T13:16:39.000Z","categories_index":"网站测试","tags_index":"测试","author_index":"LIYA的极光"}]